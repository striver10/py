out_d = {}
def outcomes(x, y):
    if (x, y) in out_d.keys():
        return out_d[x, y]
    else:     
        if y == 1:  # для последнего кубика создаем ветку, в которой будем считать итоговую возможность исхода 
            if x in range(1, 7):
                out_d[x, y] = 1
                return 1 # если до последнего кубика мы бросили сумму, которая при вычитании от входящего параметра будет меньше, либо равна 6, то комбинацию засчитываем и возвращаем в счетик 1 возможный/верный исход
            else: 
                out_d[x, y] = 0
                return 0 # если до последнего кубика мы бросили сумму, которая при вычитании от входящего параметра будет больше 6, то комбинацию не засчитываем 
        else:
            s = 0  
            for i in range(1, 7): # кидаем кубик 
                s += outcomes(x - i, y - 1) # вызываем следующий кубик, но с вычетом уже "брошенного" кубика (ов)
            out_d[x, y] = s
            return s # возвращаем количество возможных исходов в рамках ветки
    
def cuber(x, y):
    return outcomes(x, y) / (6**y) # наиболее быстрым вариантом я посчитал выделить отдельную функцию, где уже можно спокойной посчитать знаменатель (количество возможных вариантов)
